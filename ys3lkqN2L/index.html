<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leslie</title>
<meta name="description" content="" />
<link rel="shortcut icon" href="https://lihe.github.io/favicon.ico?v=1611477451643">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://lihe.github.io/styles/main.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-188000144-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-188000144-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://lihe.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://lihe.github.io/images/avatar.png?v=1611477451643" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">Leslie</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8Cconst">初始化和const</a>
<ul>
<li><a href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%E4%B8%8Bconst%E5%AF%B9%E8%B1%A1%E4%BB%85%E5%9C%A8%E6%96%87%E4%BB%B6%E5%86%85%E6%9C%89%E6%95%88">默认状态下，const对象仅在文件内有效。</a></li>
</ul>
</li>
<li><a href="#const%E7%9A%84%E5%BC%95%E7%94%A8">const的引用</a>
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%AF%B9const%E7%9A%84%E5%BC%95%E7%94%A8">初始化和对const的引用</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8Cconst">指针和const</a>
<ul>
<li><a href="#const%E6%8C%87%E9%92%88">const指针</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B6%E5%B1%82const">顶层const</a></li>
<li><a href="#constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">constexpr和常量表达式</a>
<ul>
<li><a href="#constexpr%E5%8F%98%E9%87%8F">constexpr变量</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E7%B1%BB%E5%9E%8B">字面值类型</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8Cconstexpr">指针和constexpr</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"><script type="text/javascript" src="https://s4.cnzz.com/z_stat.php?id=1279645437&web_id=1279645437"></script></div>
    <a class="rss" href="https://lihe.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">const限定符</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2021-01-24 / 17 min read
        </div>
        
          <img class="post-feature-image rounded-lg mx-auto my-4" src="https://cdn.jsdelivr.net/gh/lihe/Pic/img/20210118174902.jpg" alt="">
        
        <div class="post-content yue">
          <p>const的应用、const和指针、顶层const、constexpr和常量表达式</p>
<!-- more -->
<p>有时我们希望定义这样一种变量，它的值不能被改变。</p>
<p>例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区大小不再合适时，很容易对其进行调整。</p>
<p>另一方面，也应随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以用关键字 const 对变量的类型加以限定∶</p>
<pre><code class="language-C++">const int bufSize = 512;    // 输入缓冲区的大小
</code></pre>
<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>
<p>因为const 对象一旦创建后其值就不能再改变，所以const 对象必须初始化。一如既往，初始值可以是任意复杂的表达式∶</p>
<pre><code class="language-c++">const int i = get_size();    // 正确：运行时初始化
const int j = 42;            // 错误：编译时初始化
const int k;				 // 错误：未经初始化
</code></pre>
<h2 id="初始化和const">初始化和const</h2>
<p>正如之前反复提到的，对象的类型决定了其上的操作。</p>
<p>与非 const 类型所能参与的操作相比，const类型的对象能完成其中大部分，但也不是所有的操作都适合。</p>
<p>主要的限制就是只能在const类型的对象上执行不改变其内容的操作。</p>
<p>例如，const int 和普通的int 一样都能参与算术运算，也都能转换成一个布尔值，等等。</p>
<p>在不改变 const 对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则它们是不是 const 都无关紧要∶</p>
<pre><code class="language-c++">int i = 42;
const int ci = i;             // 正确：i的值被拷贝给了ci
int j = ci;                   // 正确：ci的值被拷贝给了j
</code></pre>
<p>尽管 ci是整型常量，但无论如何 ci 中的值还是一个整型数。ci的常量特征仅仅在执行改变 ci的操作时才会发挥作用。当用ci去初始化j时，根本无须在意ci是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。</p>
<h3 id="默认状态下const对象仅在文件内有效">默认状态下，const对象仅在文件内有效。</h3>
<p>当以编译时初始化的方式定义一个const对象时，就如bufSize的定义一样：</p>
<pre><code class="language-c++">const int bufSize = 512;
</code></pre>
<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到 bufSize 的地方，然后用 512 替换。</p>
<p>为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了 const 对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const 对象被设定为仅在文件内有效。</p>
<p>当多个文件中出现了同名的const 变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>某些时候有这样一种 const 变量，<strong>它的初始值不是一个常量表达式，但又确实有必要在文件间共享</strong>。</p>
<p>这种情况下，我们不希望编译器为每个文件分别生成独立的变量。</p>
<p>相反，我们想让这类 const 对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义 const，而在其他多个文件中声明并使用它。</p>
<p>解决的办法是，对于const 变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了∶</p>
<pre><code class="language-c++">// file_1.cpp定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize;  // 与file_1.cpp中的bufSize是同一个
</code></pre>
<p>如上述程序所示，file_1.cpp 定义并初始化了bufSize。</p>
<p>因为这条语句包含了初始值，所以它（显然）是一次定义。</p>
<p>然而，因为bufSize是一个常量，必须用extern 加以限定使其被其他文件使用。</p>
<p>file_1.h头文件中的声明也由extern做了限定，其作用是指明 bufSize并非本文件所独有，它的定义将在别处出现。</p>
<h2 id="const的引用">const的引用</h2>
<p>可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为对常量的引用（reference to const）。</p>
<p>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象∶</p>
<pre><code class="language-c++">const int ci = 1014;
const int &amp;r1 = ci;   // 正确：引用及其对象都是常量
r1 = 42;              // 错误：r1是对常量的引用
int &amp;r2 = ci;         // 错误：试图让一个非常量引用指向一个常量引用
</code></pre>
<p>因为不允许直接为 ci赋值，当然也就不能通过引用去改变 ci。因此，对 r2 的初始化是错误的。假设该初始化合法，则可以通过r2 来改变它引用对象的值，这显然是不正确的。</p>
<h3 id="初始化和对const的引用">初始化和对const的引用</h3>
<p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。</p>
<p>第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式∶</p>
<pre><code class="language-c++">int i = 42;
const int &amp;r1 = i;         // 允许将const int&amp;绑定到一个普通int对象上
const int &amp;r2 = 42;        // 正确：r2是一个常量引用
const int &amp;r3 = r1 * 2;    // 正确：r3是一个常量引用
int &amp;r4 = r1 * 2;          // 错误：r4是一个普通的非常量引用
</code></pre>
<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：</p>
<pre><code class="language-c++">double dval = 3.14;
const int &amp;ri = dval;
</code></pre>
<p>此处 ri引用了一个int 型的数。对ri的操作应该是整数运算，但 dval却是一个双精度浮点数而非整数。</p>
<p>因此为了确保让ri 绑定一个整数，编译器把上述代码变成了如下形式∶</p>
<pre><code class="language-c++">const int temp = dval;     // 由双精度浮点型生成一个临时的整型常量
const int &amp;r1 = temp;      // 让ri绑定这个临时量
</code></pre>
<p>在这种情况下，ri 绑定了一个临时量（temporary）对象。</p>
<p><strong>对const的引用可能引用一个并非const的对象</strong></p>
<p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。</p>
<p>因为对象也可能是个非常量，所以允许通过其他途径改变它的值∶</p>
<pre><code class="language-c++">int i = 41;
int &amp;r1 = i;               // 引用对象ri绑定i
const int &amp;r2 = i;         // r2也绑定对象i，但是不允许通过r2修改i的值
r1 = 0;                    // r1并非常量，i的值修改为0
r2 = 0;                    // 错误：r2是一个常量引用
</code></pre>
<p>r2 绑定（非常量）整数i是合法的行为。</p>
<p>然而，不允许通过r2 修改i的值。尽管如此， i 的值仍然允许通过其他途径修改，既可以直接给i 赋值，也可以通过像r1一样绑定到 i 的其他引用来修改。</p>
<h2 id="指针和const">指针和const</h2>
<p>与引用一样，也可以令指针指向常量或非常量。类似于常量引用，指向常量的指针（pointer to const）不能用于改变其所指对象的值。</p>
<p>要想存放常量对象的地址，只能使用指向常量的指针∶</p>
<pre><code class="language-c++">const double pi = 3.14;     // pi是个常量，它的值不能改变
double *ptr = &amp;pi;          // 错误：ptr是一个普通指针
const double *cptr = &amp;pi;   // 正确：cptr可以指向一个双精度常量
*cptr = 42;                 // 错误：不能给cptr赋值
</code></pre>
<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。</p>
<p>第一种例外情况是允许令一个指向常量的指针指向一个非常量对象∶</p>
<pre><code class="language-c++">double dval = 3.14;         // dval是一个双精度浮点数，它的值可以改变
cptr = &amp;dval;               // 正确：但是不能通过cptr改变dval的值
</code></pre>
<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。</p>
<p>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。</p>
<h3 id="const指针">const指针</h3>
<p><strong>指针是对象而引用不是</strong>，因此就像其他对象类型一样，允许把指针本身定为常量。</p>
<p>常量指针（const pointer）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。</p>
<p>把*放在 const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即<strong>不变的是指针本身的值而非指向的那个值</strong>∶</p>
<pre><code class="language-c++">int errNumb = 0;
int *const curErr = &amp;errNum;     // curErr将一直指向errNum
const double pi = 3.14159;   
const double *const pip = &amp;pi;   // pip是一个指向常量对象的常量指针
</code></pre>
<p>要想弄清楚这些声明的含义最行之有效的办法是<code>从右向左</code>阅读。此例中，离 curErr 最近的符号是 const，意味着 curErr 本身是一个常量对象，对象的类型由声明符的其余部分确定。声明符中的下一个符号是*，意思是 curErr是一个常量指针。</p>
<p>最后，该声明语句的基本数据类型部分确定了常量指针指向的是一个 int 对象。与之相似，我们也能推断出，pip是一个常量指针，它指向的对象是一个双精度浮点型常量。</p>
<p><strong>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</strong></p>
<p>例如，pip 是一个指向常量的常量指针，则不论是 pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用 curErr去修改errNumb 的值∶</p>
<pre><code class="language-c++">*pip = 2.72;            // 错误：pip是一个指向常量的指针

if (*curErr){           // 如果curErr所指的对象的值不为零
    errorHandler();
    *curErr = 0;        // 正确：把curErr所指的对象重置
}
</code></pre>
<h2 id="顶层const">顶层const</h2>
<p>如前所述，指针本身是一个对象，它又可以指向另外一个对象。</p>
<p>因此，指针<code>本身是不是常量</code>以及<code>指针所指的是不是一个常量</code>就是两个相互独立的问题。</p>
<p>用名词顶层 const（top-level const）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。</p>
<p>更一般的，顶层 const 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。</p>
<p>底层 const 则与指针和引用等复合类型的基本类型部分有关。</p>
<p>比较特殊的是，指针类型既可以是顶层 const也可以是底层const，这一点和其他类型相比区别明显∶</p>
<pre><code class="language-c++">int i = 0;
int *const p1 = &amp;i;         // 不能改变p1的值，这是一个顶层const
const int ci = 42;          // 不能改变c1的值，这是一个顶层const
const int *p2 = &amp;ci;        // 允许改变p2的值，这是一个底层const
const int *const p3 = p2;   // 第一个是底层const，第二个是顶层const
const int &amp;r = ci;          // 用于声明引用的const都是底层const
</code></pre>
<p>当执行对象的拷贝操作时，常量是顶层const 还是底层const区别明显。其中，顶层 const 不受什么影响∶</p>
<pre><code class="language-c++">i = ci;      // 正确：拷贝ci的值，ci是一个顶层const
p2 = p3;     // 正确：p2和p2指向的对象类型相同，p3的顶层const部分不影响
</code></pre>
<p>执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象是否是常量都没什么影响。</p>
<p>另一方面，底层 const 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行∶</p>
<pre><code class="language-c++">int *p = p3;           // 错误：p3包含底层const，而p没有
p2 = p3;               // 正确：p2和p3都是底层const
p2 = &amp;i;               // 正确：int*能转换成const int*
int &amp;r = ci;           // 错误：普通的int&amp;不能绑定到int常量上
const int &amp;r2 = i;     // 正确：const int&amp;可以绑定到int&amp;上
</code></pre>
<p>p3 既是顶层const也是底层 const，拷贝p3 时可以不在乎它是一个顶层const，但是<strong>必须清楚它指向的对象得是一个常量</strong>。</p>
<p>因此，不能用 p3 去初始化 p，因为p指向的是一个普通的（非常量）整数。</p>
<p>另一方面，p3的值可以赋给 p2，是因为这两个指针都是底层 const，尽管p3 同时也是一个常量指针（顶层 const），仅就这次赋值而言不会有什么影响。</p>
<h2 id="constexpr和常量表达式">constexpr和常量表达式</h2>
<p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。</p>
<p>显然，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。</p>
<p>一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如∶</p>
<pre><code class="language-c++">const int max_files = 20;          // max_files是常量表达式
const int limit = max_files + 1;   // limit是常量表达式
int staff_size = 27;               // staff_size不是常量表达式
const int sz = get_size()          // sz不是常量表达式
</code></pre>
<p>尽管 staff_size 的初始值是个字面值常量，但由于它的数据类型只是一个普通int 而非 const int，所以它不属于常量表达式。</p>
<p>另一方面，尽管 sz 本身是一个常量，但它的具体值直到运行时才能获取到，所以也不是常量表达式。</p>
<h3 id="constexpr变量">constexpr变量</h3>
<p>在一个复杂系统中，很难（几乎肯定不能）分辨一个初始值到底是不是常量表达式。当然可以定义一个 const 变量并把它的初始值设为我们认为的某个常量表达式，但在实际使用时，尽管要求如此却常常发现初始值并非常量表达式的情况。</p>
<p>可以这么说，在此种情况下，对象的定义和使用根本就是两回事儿。</p>
<p>C++11新标准规定，允许将变量声明为 constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。</p>
<p>声明为 constexpr的变量一定是一个常量，而且必须用常量表达式初始化∶</p>
<pre><code class="language-c++">constexpr int mf = 20;            // 20是常量表达式
constexpr int limit = mf + 1;     // mf + 1是常量表达式
constexpr int sz = size()         // 只有当size()是一个constexpr函数时才是要给正确的声明
</code></pre>
<p><strong>一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。</strong></p>
<h3 id="字面值类型">字面值类型</h3>
<p>常量表达式的值需要在编译时就得到计算，因此对声明 constexpr 时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为&quot;字面值类型&quot;（literal type）。</p>
<p>到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类 Sales_item、IO 库、string 类型则不属于字面值类型，也就不能被定义成 constexpr。</p>
<p>尽管指针和引用都能定义成 constexpr，但它们的初始值却受到严格限制。</p>
<p>一个 constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p>函数体内定义的变量一般来说并非存放在固定地址中，因此 constexpr 指针不能指向这样的变量。</p>
<p>相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化 constexpr指针。</p>
<p>允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr 引用能绑定到这样的变量上，constexpr 指针也能指向这样的变量。</p>
<h3 id="指针和constexpr">指针和constexpr</h3>
<p>在constexpr声明中如果定义一个指针，限定符constexpr仅对指针有效，与指针所指对象无关。</p>
<pre><code class="language-c++">const int *p = nullptr;        // p是一个指向整型常量的指针
constexpr int *q = nullptr;    // q是一个指向整数的常量指针
</code></pre>
<p>p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const。</p>
<p>与其他常量指针类似，constexpr 指针既可以指向常量也可以指向一个非常量∶</p>
<pre><code class="language-c++">constexpr int *np = nullptr;   // np是一个指向整数的常量指针，其值为空
int j = 0;
constexpr int i = 42;          // i的类型是整型常量
// i和j都必须定义在函数体之外
constexpr const int *p = &amp;i;   // p是常量指针，指向整型常量i
constexpr int *p = &amp;j;         // p1是常量指针，指向整数j
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://lihe.github.io/grKtjP_mW/">
            <span class="flex-auto">C++</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://lihe.github.io/4xUs9g4T7/">
                <h3 class="post-title">
                  如何优雅地科学上网
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://lihe.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
